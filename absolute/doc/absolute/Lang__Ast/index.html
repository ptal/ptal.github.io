<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lang__Ast (absolute.Lang__Ast)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">absolute</a> &#x00BB; Lang__Ast</nav><h1>Module <code>Lang__Ast</code></h1><p>This file represents the AST of a constraint problem. This syntactic representation can be transformed by the `Representation_sig` of an abstract domain.</p></header><dl><dt class="spec exception" id="exception-Wrong_modelling"><a href="#exception-Wrong_modelling" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Wrong_modelling</span> <span class="keyword">of</span> string</code></dt><dd><p>This exception is raised when a constraint is passed to an abstract domain that cannot represent this constraint.</p></dd></dl><dl><dt class="spec type" id="type-vname"><a href="#type-vname" class="anchor"></a><code><span class="keyword">type</span> vname</code><code> = string</code></dt><dd><p>Variables are identified by a string.</p></dd></dl><dl><dt class="spec type" id="type-i"><a href="#type-i" class="anchor"></a><code><span class="keyword">type</span> i</code><code> = <a href="../Bounds/Bound_rat/index.html#type-t">Bounds.Bound_rat.t</a></code></dt><dd><p>Constants are defined over rational because they can represent exactly integers or floating point numbers.</p></dd></dl><dl><dt class="spec type" id="type-unop"><a href="#type-unop" class="anchor"></a><code><span class="keyword">type</span> unop</code><code> = </code><table class="variant"><tr id="type-unop.NEG" class="anchored"><td class="def constructor"><a href="#type-unop.NEG" class="anchor"></a><code>| </code><code><span class="constructor">NEG</span></code></td></tr></table></dt><dd><p>Unary arithmetic operators.</p></dd></dl><dl><dt class="spec type" id="type-binop"><a href="#type-binop" class="anchor"></a><code><span class="keyword">type</span> binop</code><code> = </code><table class="variant"><tr id="type-binop.ADD" class="anchored"><td class="def constructor"><a href="#type-binop.ADD" class="anchor"></a><code>| </code><code><span class="constructor">ADD</span></code></td></tr><tr id="type-binop.SUB" class="anchored"><td class="def constructor"><a href="#type-binop.SUB" class="anchor"></a><code>| </code><code><span class="constructor">SUB</span></code></td></tr><tr id="type-binop.MUL" class="anchored"><td class="def constructor"><a href="#type-binop.MUL" class="anchor"></a><code>| </code><code><span class="constructor">MUL</span></code></td></tr><tr id="type-binop.DIV" class="anchored"><td class="def constructor"><a href="#type-binop.DIV" class="anchor"></a><code>| </code><code><span class="constructor">DIV</span></code></td></tr><tr id="type-binop.POW" class="anchored"><td class="def constructor"><a href="#type-binop.POW" class="anchor"></a><code>| </code><code><span class="constructor">POW</span></code></td></tr></table></dt><dd><p>Binary arithmetic operators.</p></dd></dl><dl><dt class="spec type" id="type-cmpop"><a href="#type-cmpop" class="anchor"></a><code><span class="keyword">type</span> cmpop</code><code> = </code><table class="variant"><tr id="type-cmpop.EQ" class="anchored"><td class="def constructor"><a href="#type-cmpop.EQ" class="anchor"></a><code>| </code><code><span class="constructor">EQ</span></code></td></tr><tr id="type-cmpop.LEQ" class="anchored"><td class="def constructor"><a href="#type-cmpop.LEQ" class="anchor"></a><code>| </code><code><span class="constructor">LEQ</span></code></td></tr><tr id="type-cmpop.GEQ" class="anchored"><td class="def constructor"><a href="#type-cmpop.GEQ" class="anchor"></a><code>| </code><code><span class="constructor">GEQ</span></code></td></tr><tr id="type-cmpop.NEQ" class="anchored"><td class="def constructor"><a href="#type-cmpop.NEQ" class="anchor"></a><code>| </code><code><span class="constructor">NEQ</span></code></td></tr><tr id="type-cmpop.GT" class="anchored"><td class="def constructor"><a href="#type-cmpop.GT" class="anchor"></a><code>| </code><code><span class="constructor">GT</span></code></td></tr><tr id="type-cmpop.LT" class="anchored"><td class="def constructor"><a href="#type-cmpop.LT" class="anchor"></a><code>| </code><code><span class="constructor">LT</span></code></td></tr></table></dt><dd><p>Arithmetic comparison operators.</p></dd></dl><dl><dt class="spec type" id="type-expr"><a href="#type-expr" class="anchor"></a><code><span class="keyword">type</span> expr</code><code> = </code><table class="variant"><tr id="type-expr.Funcall" class="anchored"><td class="def constructor"><a href="#type-expr.Funcall" class="anchor"></a><code>| </code><code><span class="constructor">Funcall</span> <span class="keyword">of</span> string * <span><a href="index.html#type-expr">expr</a> list</span></code></td></tr><tr id="type-expr.Unary" class="anchored"><td class="def constructor"><a href="#type-expr.Unary" class="anchor"></a><code>| </code><code><span class="constructor">Unary</span> <span class="keyword">of</span> <a href="index.html#type-unop">unop</a> * <a href="index.html#type-expr">expr</a></code></td></tr><tr id="type-expr.Binary" class="anchored"><td class="def constructor"><a href="#type-expr.Binary" class="anchor"></a><code>| </code><code><span class="constructor">Binary</span> <span class="keyword">of</span> <a href="index.html#type-expr">expr</a> * <a href="index.html#type-binop">binop</a> * <a href="index.html#type-expr">expr</a></code></td></tr><tr id="type-expr.Var" class="anchored"><td class="def constructor"><a href="#type-expr.Var" class="anchor"></a><code>| </code><code><span class="constructor">Var</span> <span class="keyword">of</span> <a href="index.html#type-vname">vname</a></code></td></tr><tr id="type-expr.Cst" class="anchored"><td class="def constructor"><a href="#type-expr.Cst" class="anchor"></a><code>| </code><code><span class="constructor">Cst</span> <span class="keyword">of</span> <a href="index.html#type-i">i</a> * <a href="../Core/Types/index.html#type-var_concrete_ty">Core.Types.var_concrete_ty</a></code></td></tr></table></dt><dt class="spec type" id="type-bconstraint"><a href="#type-bconstraint" class="anchor"></a><code><span class="keyword">type</span> bconstraint</code><code> = <a href="index.html#type-expr">expr</a> * <a href="index.html#type-cmpop">cmpop</a> * <a href="index.html#type-expr">expr</a></code></dt><dd><p>A binary constraint.</p></dd></dl><dl><dt class="spec type" id="type-formula"><a href="#type-formula" class="anchor"></a><code><span class="keyword">type</span> formula</code><code> = </code><table class="variant"><tr id="type-formula.FVar" class="anchored"><td class="def constructor"><a href="#type-formula.FVar" class="anchor"></a><code>| </code><code><span class="constructor">FVar</span> <span class="keyword">of</span> <a href="index.html#type-vname">vname</a></code></td></tr><tr id="type-formula.Cmp" class="anchored"><td class="def constructor"><a href="#type-formula.Cmp" class="anchor"></a><code>| </code><code><span class="constructor">Cmp</span> <span class="keyword">of</span> <a href="index.html#type-bconstraint">bconstraint</a></code></td></tr><tr id="type-formula.Equiv" class="anchored"><td class="def constructor"><a href="#type-formula.Equiv" class="anchor"></a><code>| </code><code><span class="constructor">Equiv</span> <span class="keyword">of</span> <a href="index.html#type-formula">formula</a> * <a href="index.html#type-formula">formula</a></code></td></tr><tr id="type-formula.Imply" class="anchored"><td class="def constructor"><a href="#type-formula.Imply" class="anchor"></a><code>| </code><code><span class="constructor">Imply</span> <span class="keyword">of</span> <a href="index.html#type-formula">formula</a> * <a href="index.html#type-formula">formula</a></code></td></tr><tr id="type-formula.And" class="anchored"><td class="def constructor"><a href="#type-formula.And" class="anchor"></a><code>| </code><code><span class="constructor">And</span> <span class="keyword">of</span> <a href="index.html#type-formula">formula</a> * <a href="index.html#type-formula">formula</a></code></td></tr><tr id="type-formula.Or" class="anchored"><td class="def constructor"><a href="#type-formula.Or" class="anchor"></a><code>| </code><code><span class="constructor">Or</span> <span class="keyword">of</span> <a href="index.html#type-formula">formula</a> * <a href="index.html#type-formula">formula</a></code></td></tr><tr id="type-formula.Not" class="anchored"><td class="def constructor"><a href="#type-formula.Not" class="anchor"></a><code>| </code><code><span class="constructor">Not</span> <span class="keyword">of</span> <a href="index.html#type-formula">formula</a></code></td></tr></table></dt><dd><p>Propositional logic formula.</p></dd></dl><dl><dt class="spec type" id="type-qformula"><a href="#type-qformula" class="anchor"></a><code><span class="keyword">type</span> qformula</code><code> = </code><table class="variant"><tr id="type-qformula.QFFormula" class="anchored"><td class="def constructor"><a href="#type-qformula.QFFormula" class="anchor"></a><code>| </code><code><span class="constructor">QFFormula</span> <span class="keyword">of</span> <a href="index.html#type-formula">formula</a></code></td></tr><tr id="type-qformula.Exists" class="anchored"><td class="def constructor"><a href="#type-qformula.Exists" class="anchor"></a><code>| </code><code><span class="constructor">Exists</span> <span class="keyword">of</span> <a href="index.html#type-vname">vname</a> * <a href="../Core/Types/index.html#type-var_ty">Core.Types.var_ty</a> * <a href="index.html#type-qformula">qformula</a></code></td></tr></table></dt><dd><p>Formula with existential quantifier. It is mainly useful for declaring the concrete type of a variable's value.</p></dd></dl><dl><dt class="spec type" id="type-optimization_kind"><a href="#type-optimization_kind" class="anchor"></a><code><span class="keyword">type</span> optimization_kind</code><code> = </code><table class="variant"><tr id="type-optimization_kind.Minimize" class="anchored"><td class="def constructor"><a href="#type-optimization_kind.Minimize" class="anchor"></a><code>| </code><code><span class="constructor">Minimize</span> <span class="keyword">of</span> <a href="index.html#type-vname">vname</a></code></td></tr><tr id="type-optimization_kind.Maximize" class="anchored"><td class="def constructor"><a href="#type-optimization_kind.Maximize" class="anchor"></a><code>| </code><code><span class="constructor">Maximize</span> <span class="keyword">of</span> <a href="index.html#type-vname">vname</a></code></td></tr><tr id="type-optimization_kind.Satisfy" class="anchored"><td class="def constructor"><a href="#type-optimization_kind.Satisfy" class="anchor"></a><code>| </code><code><span class="constructor">Satisfy</span></code></td></tr></table></dt><dt class="spec type" id="type-bab_qformula"><a href="#type-bab_qformula" class="anchor"></a><code><span class="keyword">type</span> bab_qformula</code><code> = </code><code>{</code><table class="record"><tr id="type-bab_qformula.qf" class="anchored"><td class="def field"><a href="#type-bab_qformula.qf" class="anchor"></a><code>qf : <a href="index.html#type-qformula">qformula</a>;</code></td></tr><tr id="type-bab_qformula.optimise" class="anchored"><td class="def field"><a href="#type-bab_qformula.optimise" class="anchor"></a><code>optimise : <a href="index.html#type-optimization_kind">optimization_kind</a>;</code></td></tr></table><code>}</code></dt><dd><p>Data structure to store a formula along with its variable to optimise.</p></dd></dl><dl><dt class="spec value" id="val-zero"><a href="#val-zero" class="anchor"></a><code><span class="keyword">val</span> zero : <a href="index.html#type-expr">expr</a></code></dt><dt class="spec value" id="val-one"><a href="#val-one" class="anchor"></a><code><span class="keyword">val</span> one : <a href="index.html#type-expr">expr</a></code></dt><dt class="spec value" id="val-two"><a href="#val-two" class="anchor"></a><code><span class="keyword">val</span> two : <a href="index.html#type-expr">expr</a></code></dt><dt class="spec value" id="val-truef"><a href="#val-truef" class="anchor"></a><code><span class="keyword">val</span> truef : <a href="index.html#type-formula">formula</a></code></dt><dd><p>Encoding of true and false as formula.</p></dd></dl><dl><dt class="spec value" id="val-falsef"><a href="#val-falsef" class="anchor"></a><code><span class="keyword">val</span> falsef : <a href="index.html#type-formula">formula</a></code></dt><dt class="spec value" id="val-has_variable"><a href="#val-has_variable" class="anchor"></a><code><span class="keyword">val</span> has_variable : <a href="index.html#type-expr">expr</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Checks if an expression contains a variable.</p></dd></dl><dl><dt class="spec value" id="val-is_linear"><a href="#val-is_linear" class="anchor"></a><code><span class="keyword">val</span> is_linear : <a href="index.html#type-expr">expr</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Checks if an expression is linear.</p></dd></dl><dl><dt class="spec value" id="val-is_cons_linear"><a href="#val-is_cons_linear" class="anchor"></a><code><span class="keyword">val</span> is_cons_linear : <a href="index.html#type-formula">formula</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Checks if a constraint is linear.</p></dd></dl><dl><dt class="spec value" id="val-is_cst"><a href="#val-is_cst" class="anchor"></a><code><span class="keyword">val</span> is_cst : <a href="index.html#type-expr">expr</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-type_dispatch"><a href="#val-type_dispatch" class="anchor"></a><code><span class="keyword">val</span> type_dispatch : <span>(<span class="keyword">module</span> <a href="../Bounds/Bound_sig/module-type-S/index.html">Bounds.Bound_sig.S</a>)</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="../Core/Types/index.html#type-var_ty">Core.Types.var_ty</a> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>type_dispatch B from ty f</code>. Given bound signature that is supported by an abstract domain, verify that the type is compatible with that signature, and call `f ()`. Raise `Wrong_modelling` in case of an incompatibility with a message including the name of the abstract domain `from`.</p></dd></dl></div></body></html>