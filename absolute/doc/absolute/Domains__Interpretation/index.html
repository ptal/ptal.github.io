<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Domains__Interpretation (absolute.Domains__Interpretation)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">absolute</a> &#x00BB; Domains__Interpretation</nav><h1>Module <code>Domains__Interpretation</code></h1></header><dl><dt class="spec type" id="type-approx_kind"><a href="#type-approx_kind" class="anchor"></a><code><span class="keyword">type</span> approx_kind</code><code> = </code><table class="variant"><tr id="type-approx_kind.Exact" class="anchored"><td class="def constructor"><a href="#type-approx_kind.Exact" class="anchor"></a><code>| </code><code><span class="constructor">Exact</span></code></td></tr><tr id="type-approx_kind.UnderApprox" class="anchored"><td class="def constructor"><a href="#type-approx_kind.UnderApprox" class="anchor"></a><code>| </code><code><span class="constructor">UnderApprox</span></code></td></tr><tr id="type-approx_kind.OverApprox" class="anchored"><td class="def constructor"><a href="#type-approx_kind.OverApprox" class="anchor"></a><code>| </code><code><span class="constructor">OverApprox</span></code></td></tr></table></dt><dd><p>The kind of approximation when interpreting a logical formula into an abstract element. Note that the values `UnderApprox` or `OverApprox` interpret the constraint exactly if it is possible. Over-approximation: the abstract element might have more solutions than the concrete solutions of the formula. Under-approximation: the abstract element might have less solutions than the concrete solutions of the formula.</p></dd></dl><dl><dt class="spec value" id="val-neg_approx"><a href="#val-neg_approx" class="anchor"></a><code><span class="keyword">val</span> neg_approx : <a href="index.html#type-approx_kind">approx_kind</a> <span>&#45;&gt;</span> <a href="index.html#type-approx_kind">approx_kind</a></code></dt><dd><p>Over-approximation becomes under-approximation, and vice-versa.</p></dd></dl><dl><dt class="spec value" id="val-string_of_approx"><a href="#val-string_of_approx" class="anchor"></a><code><span class="keyword">val</span> string_of_approx : <a href="index.html#type-approx_kind">approx_kind</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Past participle form of the verb representing the approximation (i.e. &quot;under-approximated&quot;).</p></dd></dl><dl><dt class="spec value" id="val-no_variable_exn"><a href="#val-no_variable_exn" class="anchor"></a><code><span class="keyword">val</span> no_variable_exn : string <span>&#45;&gt;</span> unit</code></dt><dd><p>Common error message for abstract domains that do not support variables (although their sub-domains might support variables).</p></dd></dl><dl><dt class="spec module-type" id="module-type-Interpretation_sig"><a href="#module-type-Interpretation_sig" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Interpretation_sig/index.html">Interpretation_sig</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Every abstract domain may have a different variable and constraint representation according to their internal implementation. We ask every abstract domain to provide an interpretation module in order to connect the logic specification (`Ast.tqformula`) and the representation of the abstract domain. This module can also interpret a logic constraint into a more suited representation of the abstract domain. Rational: Why not directly pushing these functions into the definition of the abstract domain? We could parametrize the abstract domain by an interpretation although we do not do it yet. Another reason is that sometimes, we want to convert a formula into a abstract domain's constraint but without adding this formula in the abstract domain yet. This is for example the case with equivalence constraint &quot;c1 &lt;=&gt; c2&quot;. We avoid the overhead of converting the logical to abstract constraint during the computation.</p></dd></dl><div class="spec module" id="module-Interpretation_base"><a href="#module-Interpretation_base" class="anchor"></a><code><span class="keyword">module</span> <a href="Interpretation_base/index.html">Interpretation_base</a> : <span class="keyword">functor</span> (<a href="Interpretation_base/argument-1-V_ID/index.html">V_ID</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-guarded_extend"><a href="#val-guarded_extend" class="anchor"></a><code><span class="keyword">val</span> guarded_extend : <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../Typing/Ad_type/index.html#type-ad_uid">Typing.Ad_type.ad_uid</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="../Typing/Tast/index.html#type-tvariable">Typing.Tast.tvariable</a> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../Typing/Tast/index.html#type-tvariable">Typing.Tast.tvariable</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span><span class="type-var">'b</span> list</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span><span class="type-var">'b</span> list</span></code></dt><dd><p><code>guarded_extend a uid ad_name tv next</code> is a helper function to extend domain with a variable. It checks that the formula's UID matches the one of the domain, and that the formula is not a tautology.</p></dd></dl><dl><dt class="spec value" id="val-guarded_interpret"><a href="#val-guarded_interpret" class="anchor"></a><code><span class="keyword">val</span> guarded_interpret : <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../Typing/Ad_type/index.html#type-ad_uid">Typing.Ad_type.ad_uid</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="../Typing/Tast/index.html#type-tformula">Typing.Tast.tformula</a> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../Typing/Tast/index.html#type-tformula">Typing.Tast.tformula</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span><span class="type-var">'b</span> list</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span><span class="type-var">'b</span> list</span></code></dt><dd><p><code>guarded_interpret a uid ad_name tf next</code> is a helper function to interpret a formula. It checks that the formula's UID matches the one of the domain, and that the formula is not a tautology.</p></dd></dl><dl><dt class="spec value" id="val-ground_interpret"><a href="#val-ground_interpret" class="anchor"></a><code><span class="keyword">val</span> ground_interpret : <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../Typing/Ad_type/index.html#type-ad_uid">Typing.Ad_type.ad_uid</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="../Typing/Tast/index.html#type-tformula">Typing.Tast.tformula</a> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../Lang/Ast/index.html#type-bconstraint">Lang.Ast.bconstraint</a> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span><span class="type-var">'b</span> list</span></code></dt><dd><p><code>ground_interpret a uid ad_name tf interpret_bconstraint</code> traverses the formula and interpret every constraint. Raises Wrong_modelling if logic connectors other than conjunctions are present in the formula.</p></dd></dl><dl><dt class="spec module" id="module-Interpretation_ground"><a href="#module-Interpretation_ground" class="anchor"></a><code><span class="keyword">module</span> <a href="Interpretation_ground/index.html">Interpretation_ground</a> : <span class="keyword">functor</span> (<a href="Interpretation_ground/argument-1-V_ID/index.html">V_ID</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Helper functions to interpret and transform constraints in ground abstract domains.</p></dd></dl></div></body></html>