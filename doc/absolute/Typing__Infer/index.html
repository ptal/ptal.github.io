<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Typing__Infer (absolute.Typing__Infer)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">absolute</a> &#x00BB; Typing__Infer</nav><h1>Module <code>Typing__Infer</code></h1><p>This module attempt to give a type to each component of a logical formula. In our context, a type is a list of UIDs representing the abstract domains in which the part of a formula can be typed.</p><p>NOTE: Only the function <code>infer_type</code> should be useful for users of this module, but we also give the functions of the inference engine for documentation purposes.</p></header><dl><dt class="spec type" id="type-inferred_type"><a href="#type-inferred_type" class="anchor"></a><code><span class="keyword">type</span> inferred_type</code><code> = </code><table class="variant"><tr id="type-inferred_type.CannotType" class="anchored"><td class="def constructor"><a href="#type-inferred_type.CannotType" class="anchor"></a><code>| </code><code><span class="constructor">CannotType</span> <span class="keyword">of</span> string</code></td></tr><tr id="type-inferred_type.Typed" class="anchored"><td class="def constructor"><a href="#type-inferred_type.Typed" class="anchor"></a><code>| </code><code><span class="constructor">Typed</span> <span class="keyword">of</span> <span><a href="../Typing/Ad_type/index.html#type-ad_uid">Typing.Ad_type.ad_uid</a> list</span></code></td></tr></table></dt><dd><p>The type inferred from a formula. In case the user already provided some UIDs, we flag these with a Boolean.</p></dd></dl><dl><dt class="spec value" id="val-merge_ity"><a href="#val-merge_ity" class="anchor"></a><code><span class="keyword">val</span> merge_ity : <a href="index.html#type-inferred_type">inferred_type</a> <span>&#45;&gt;</span> <a href="index.html#type-inferred_type">inferred_type</a> <span>&#45;&gt;</span> <a href="index.html#type-inferred_type">inferred_type</a></code></dt></dl><dl><dt class="spec type" id="type-iformula"><a href="#type-iformula" class="anchor"></a><code><span class="keyword">type</span> iformula</code><code> = <span><a href="index.html#type-inferred_type">inferred_type</a> <a href="../Typing/Aast/index.html#type-aformula">Typing.Aast.aformula</a></span></code></dt><dd><p>We equip a formula with the UIDs of abstract elements in which it can be interpreted. The UID `0` is by default the largest abstract type avalaible (usually a product among the available abstract domains).</p></dd></dl><dl><dt class="spec type" id="type-iqformula"><a href="#type-iqformula" class="anchor"></a><code><span class="keyword">type</span> iqformula</code><code> = <span><a href="index.html#type-inferred_type">inferred_type</a> <a href="../Typing/Aast/index.html#type-aqformula">Typing.Aast.aqformula</a></span></code></dt></dl><dl><dt class="spec value" id="val-uids_of'"><a href="#val-uids_of'" class="anchor"></a><code><span class="keyword">val</span> uids_of' : <a href="index.html#type-inferred_type">inferred_type</a> <span>&#45;&gt;</span> <span><a href="../Typing/Ad_type/index.html#type-ad_uid">Typing.Ad_type.ad_uid</a> list</span></code></dt><dt class="spec value" id="val-uids_of"><a href="#val-uids_of" class="anchor"></a><code><span class="keyword">val</span> uids_of : <a href="index.html#type-iformula">iformula</a> <span>&#45;&gt;</span> <span><a href="../Typing/Ad_type/index.html#type-ad_uid">Typing.Ad_type.ad_uid</a> list</span></code></dt><dt class="spec value" id="val-is_uid_in"><a href="#val-is_uid_in" class="anchor"></a><code><span class="keyword">val</span> is_uid_in : <a href="../Typing/Ad_type/index.html#type-ad_uid">Typing.Ad_type.ad_uid</a> <span>&#45;&gt;</span> <a href="index.html#type-iformula">iformula</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_uid_in2"><a href="#val-is_uid_in2" class="anchor"></a><code><span class="keyword">val</span> is_uid_in2 : <a href="../Typing/Ad_type/index.html#type-ad_uid">Typing.Ad_type.ad_uid</a> <span>&#45;&gt;</span> <a href="index.html#type-iformula">iformula</a> <span>&#45;&gt;</span> <a href="index.html#type-iformula">iformula</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-formula_to_iformula"><a href="#val-formula_to_iformula" class="anchor"></a><code><span class="keyword">val</span> formula_to_iformula : <a href="../Lang/Ast/index.html#type-formula">Lang.Ast.formula</a> <span>&#45;&gt;</span> <a href="index.html#type-iformula">iformula</a></code></dt><dd><p>See <code>qformula_to_iqformula</code>.</p></dd></dl><dl><dt class="spec value" id="val-qformula_to_iqformula"><a href="#val-qformula_to_iqformula" class="anchor"></a><code><span class="keyword">val</span> qformula_to_iqformula : <a href="../Lang/Ast/index.html#type-qformula">Lang.Ast.qformula</a> <span>&#45;&gt;</span> <a href="index.html#type-iqformula">iqformula</a></code></dt><dd><p>Convert an untyped formula to a formula with a empty type (Typed <code></code>) that will be populated.</p></dd></dl><dl><dt class="spec module" id="module-Inference"><a href="#module-Inference" class="anchor"></a><code><span class="keyword">module</span> <a href="Inference/index.html">Inference</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Module containing all the necessary information to type a formula with a given abstract domain type.</p></dd></dl><dl><dt class="spec value" id="val-make_tqformula"><a href="#val-make_tqformula" class="anchor"></a><code><span class="keyword">val</span> make_tqformula : <span><a href="../Typing/Ad_type/index.html#type-ad_uid">Typing.Ad_type.ad_uid</a> <a href="../Typing/Aast/index.html#type-aqformula">Typing.Aast.aqformula</a></span> <span>&#45;&gt;</span> <a href="../Typing/Tast/index.html#type-tqformula">Typing.Tast.tqformula</a></code></dt><dd><p>Final step of the typing process where the formula is cleaned with the UID information.</p></dd></dl><dl><dt class="spec value" id="val-infer_type"><a href="#val-infer_type" class="anchor"></a><code><span class="keyword">val</span> infer_type : <a href="../Typing/Ad_type/index.html#type-ad_ty">Typing.Ad_type.ad_ty</a> <span>&#45;&gt;</span> <a href="../Lang/Ast/index.html#type-qformula">Lang.Ast.qformula</a> <span>&#45;&gt;</span> <a href="../Typing/Tast/index.html#type-tqformula">Typing.Tast.tqformula</a></code></dt><dd><p>Given an abstract domain type and an untyped formula, infer the type of each component of the formula matching the given abstract domain. Raises `Wrong_modelling msg` if the formula is not typable for this abstract domain's type; `msg` should explain why the formula is not typable. Note: `ad_ty` encompasses domain transformers including product such as &quot;t1 X t2&quot;, thus part of a formula might be typed with `t1` or `t2`.</p></dd></dl></div></body></html>