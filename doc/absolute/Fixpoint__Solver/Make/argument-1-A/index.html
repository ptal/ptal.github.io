<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>1-A (absolute.Fixpoint__Solver.Make.1-A)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../index.html">absolute</a> &#x00BB; <a href="../../index.html">Fixpoint__Solver</a> &#x00BB; <a href="../index.html">Make</a> &#x00BB; 1-A</nav><h1>Parameter <code>Make.1-A</code></h1></header><dl><dt class="spec module" id="module-I"><a href="#module-I" class="anchor"></a><code><span class="keyword">module</span> <a href="I/index.html">I</a> : <a href="../../../Domains/Interpretation/index.html#module-type-Interpretation_sig">Domains.Interpretation.Interpretation_sig</a></code></dt><dd><p>The representation of the variables and constraints inside the abstract element. It allows users to turn a logic specification into an abstract element.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type of the abstract domain.</p></dd></dl><dl><dt class="spec module" id="module-B"><a href="#module-B" class="anchor"></a><code><span class="keyword">module</span> <a href="B/index.html">B</a> : <a href="../../../Bounds/Bound_sig/index.html#module-type-S">Bounds.Bound_sig.S</a></code></dt><dd><p>The module of the bound handled by this abstract domain.</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <a href="../../../Typing/Ad_type/index.html#type-ad_uid">Typing.Ad_type.ad_uid</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>An empty abstract element identified by a unique identifier (UID). See also `uid`.</p></dd></dl><dl><dt class="spec value" id="val-uid"><a href="#val-uid" class="anchor"></a><code><span class="keyword">val</span> uid : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../Typing/Ad_type/index.html#type-ad_uid">Typing.Ad_type.ad_uid</a></code></dt><dd><p>Retrieve the UID of this abstract element. For instance, UIDs are useful to perform event-based propagation and to associate event and task to a specific abstract element. See also `Transformers.Event_loop`.</p></dd></dl><dl><dt class="spec value" id="val-name"><a href="#val-name" class="anchor"></a><code><span class="keyword">val</span> name : string</code></dt><dd><p>Name of the abstract domain. This is particularly useful to print `Wrong_modelling` messages.</p></dd></dl><dl><dt class="spec value" id="val-type_of"><a href="#val-type_of" class="anchor"></a><code><span class="keyword">val</span> type_of : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../../../Typing/Ad_type/index.html#type-ad_ty">Typing.Ad_type.ad_ty</a> option</span></code></dt><dd><p>Synthesize the type of the current abstract element. This function is useful once you created an abstract element, and wish to retrieve a symbolic representation of this element. See also <code>Typing.Infer</code>. `None` if the abstract element does not have a &quot;useful type&quot; (for instance if it cannot represent constraints, e.g. `Event_loop`).</p></dd></dl><dl><dt class="spec value" id="val-interpretation"><a href="#val-interpretation" class="anchor"></a><code><span class="keyword">val</span> interpretation : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="I/index.html#type-t">I.t</a></code></dt><dd><p>Read-only access to the interpretation structure.</p></dd></dl><dl><dt class="spec value" id="val-map_interpretation"><a href="#val-map_interpretation" class="anchor"></a><code><span class="keyword">val</span> map_interpretation : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>(<a href="I/index.html#type-t">I.t</a> <span>&#45;&gt;</span> <a href="I/index.html#type-t">I.t</a> * <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <span class="type-var">'a</span></code></dt><dd><p>Allow to modify the interpretation. Be careful using this function as it delegates to you the work to keep the interpretation and abstract domain consistent.</p></dd></dl><dl><dt class="spec value" id="val-interpret"><a href="#val-interpret" class="anchor"></a><code><span class="keyword">val</span> interpret : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../Domains/Interpretation/index.html#type-approx_kind">Domains.Interpretation.approx_kind</a> <span>&#45;&gt;</span> <a href="../../../Typing/Tast/index.html#type-tqformula">Typing.Tast.tqformula</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <span><a href="I/index.html#type-rconstraint">I.rconstraint</a> list</span></code></dt><dd><p>Interpret an existentially quantified logical formula into an abstract element. 1. Existentially quantified variables are added into the abstract element if not already present. 2. Constraints are transformed into `rconstraint` and can be added into the abstract element with `weak_incremental_closure`.</p><p>Usage: It should be considered as an incremental interpretation function. For instance, if you interpret `∃x∃y.x &lt; y` first, and then interpret `∃y∃z.y = z`, it is equivalent to: `∃x∃y∃z.x &lt; y /\ y = z`. You can add a variable without constraints with `∃x.true`; use `I.to_logic_variable` to retrieve the `var_id` and other information about &quot;x&quot;.</p><p>Exception: Raise `Wrong_modelling` if: 1. the constraint could not be interpreted, or 2. some free variables are not already in the abstract element. Raise `Bot_found` if the constraint is detected unsatisfiable (this is optional).</p><p>Note: All variables are supposed to have a different name, otherwise they are considered equal; this differs from the usual existential connector in logic.</p><p>See also `Interpretation_sig.interpret`.</p></dd></dl><dl><dt class="spec value" id="val-project"><a href="#val-project" class="anchor"></a><code><span class="keyword">val</span> project : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="I/index.html#type-var_id">I.var_id</a> <span>&#45;&gt;</span> <a href="B/index.html#type-t">B.t</a> * <a href="B/index.html#type-t">B.t</a></code></dt><dd><p>Project the lower and upper bounds of a single variable. Raise `Wrong_modelling` if the variable is not in the current abstract element.</p></dd></dl><dl><dt class="spec value" id="val-embed"><a href="#val-embed" class="anchor"></a><code><span class="keyword">val</span> embed : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="I/index.html#type-var_id">I.var_id</a> <span>&#45;&gt;</span> <span>(<a href="B/index.html#type-t">B.t</a> * <a href="B/index.html#type-t">B.t</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>embed abs x (l,u)</code> joins the value of the variable `x` with the interval `(l,u)` into `abs`. It should be equivalent to: `List.fold_left weak_incremental_closure abs (interpret abs Exact (x &gt;= l /\ x &lt;= u))`. This function is mainly useful for efficiency purposes.</p></dd></dl><dl><dt class="spec type" id="type-snapshot"><a href="#type-snapshot" class="anchor"></a><code><span class="keyword">type</span> snapshot</code></dt><dd><p>A snapshot is a copy of the state of the abstract domain at some point in time. For purely functional abstract domains, it will be equal to `t`.</p></dd></dl><dl><dt class="spec value" id="val-lazy_copy"><a href="#val-lazy_copy" class="anchor"></a><code><span class="keyword">val</span> lazy_copy : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><a href="index.html#type-snapshot">snapshot</a> list</span></code></dt><dd><p><code>lazy_copy a n</code> creates a series of `n` snapshots of the current element `a`. For purely functional abstract domain, it is as easy as `List.init n (fun _ -&gt; a)`. Postcondition: `a` must not be used anymore unless in `restore`. Internally, some informations can be shared by the different snapshots (until restored). This function is useful in a backtracking algorithm.</p></dd></dl><dl><dt class="spec value" id="val-restore"><a href="#val-restore" class="anchor"></a><code><span class="keyword">val</span> restore : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-snapshot">snapshot</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Restore the abstract element to the same state as when the snapshot was created.</p></dd></dl><dl><dt class="spec value" id="val-closure"><a href="#val-closure" class="anchor"></a><code><span class="keyword">val</span> closure : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Closure of the abstract element: it tries to remove as much inconsistent values as possible from the abstract element according to the encapsulated constraints (added through `weak_incremental_closure`).</p></dd></dl><dl><dt class="spec value" id="val-weak_incremental_closure"><a href="#val-weak_incremental_closure" class="anchor"></a><code><span class="keyword">val</span> weak_incremental_closure : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="I/index.html#type-rconstraint">I.rconstraint</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Weak incremental closure add the constraint into the abstract element. This operation should be of low time complexity. Raise `Bot_found` if the constraint is detected unsatisfiable (this is optional). Precondition: The variables in the constraint must all belong to the abstract element.</p></dd></dl><dl><dt class="spec value" id="val-entailment"><a href="#val-entailment" class="anchor"></a><code><span class="keyword">val</span> entailment : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="I/index.html#type-rconstraint">I.rconstraint</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <a href="I/index.html#type-rconstraint">I.rconstraint</a> * bool</code></dt><dd><p><code>(a',c',b) = entailment a c</code> has `b` equal to `true` if the constraint `c` is entailed by the abstract element `a`. `a'` and `c'` must be semantically equivalent to `a` and `c`, but `c` might be simplified for better efficiency of subsequent entailment requests. Note that `let entailment a c = (a,c, &lt;compute_entailment&gt;)` is a totally valid implementation.</p><p>Being entailed means that the constraint is redundant in comparison to the information already in `a`. To test for disentailment, you must call `entailment` on the negation of the constraint. It is not possible to return a `Kleene` value due to over-approximation of constraint. Indeed, `c` might be an over-approximation of its logical constraint `l`, and therefore the disentailment of `c` does not imply the disentailment of `l`. This is explained more formally in the paper &quot;Combining Constraint Languages via Abstract Interpretation&quot; (Talbot and al., 2019).</p></dd></dl><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : <span>?&#8288;strategy:<a href="../../../Domains/Abstract_domain/index.html#type-search_strategy">Domains.Abstract_domain.search_strategy</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-snapshot">snapshot</a> list</span></code></dt><dd><p>Divide the abstract element into sub-elements. For exhaustiveness, the union of `split a` should be equal to `a`. The list is empty if the abstract element cannot be split either because: * `state a != unknown`, or * It delegates the split to other domains, or * The provided search strategy is already fully evaluated. Raise `Wrong_modelling` if the search strategy is not supported.</p><p>Note: A search strategy contains variable `vname` which are string. For efficiency, it is better if the abstract domain evaluates these `vname` to `var_id` once. It can be done by testing for physical equality the strategy argument and evaluating these vname only when it changes (see <code>Box.split</code>).</p></dd></dl><dl><dt class="spec value" id="val-volume"><a href="#val-volume" class="anchor"></a><code><span class="keyword">val</span> volume : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> float</code></dt><dd><p>The volume is crucial to get information on the current state of the abstract element:</p><ul><li>`volume t = 0` means that the current abstract element is failed.</li><li>`volume t = 1` (on integers) means that the current assignment is satisfiable (note that `1` is exactly representable in a floating point number).</li><li>On float and rational, the notion of &quot;satisfiability&quot; depends on the expected precision of the abstract element.</li></ul></dd></dl><dl><dt class="spec value" id="val-state"><a href="#val-state" class="anchor"></a><code><span class="keyword">val</span> state : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../Core/Kleene/index.html#type-t">Core.Kleene.t</a></code></dt><dd><p>An element belongs to one category: failed, satisfiable and unknown. Note that this function cannot be recovered from `volume` because `state` can return satisfiable even if `volume t &gt; 1`. Normally, `False` is never returned because `Bot_found` is raised in case of unsatisfiability in `weak_incremental_closure` or `closure`.</p></dd></dl><dl><dt class="spec value" id="val-print"><a href="#val-print" class="anchor"></a><code><span class="keyword">val</span> print : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the current element in the abstract element using the logical names of variables.</p></dd></dl><dl><dt class="spec value" id="val-has_changed"><a href="#val-has_changed" class="anchor"></a><code><span class="keyword">val</span> has_changed : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>has_changed t</code> is `true` if some events were generated in this abstract element and not yet drained (see <code>drain_events</code>). If <code>has_changed t</code> is `true` after a call to `closure`, it means that `closure` is at a fixed point.</p></dd></dl><dl><dt class="spec value" id="val-drain_events"><a href="#val-drain_events" class="anchor"></a><code><span class="keyword">val</span> drain_events : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <span><a href="../../../Domains/Abstract_domain/index.html#type-event">Domains.Abstract_domain.event</a> list</span></code></dt><dd><p><code>drain_events t</code> returns the events produced since the last call. The events are removed from `t`, so an immediate next call will return an empty list.</p></dd></dl><dl><dt class="spec value" id="val-events_of"><a href="#val-events_of" class="anchor"></a><code><span class="keyword">val</span> events_of : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="I/index.html#type-rconstraint">I.rconstraint</a> <span>&#45;&gt;</span> <span><a href="../../../Domains/Abstract_domain/index.html#type-event">Domains.Abstract_domain.event</a> list</span></code></dt><dd><p><code>events_of t c</code> returns the events of the constraints `c`.</p></dd></dl><dl><dt class="spec value" id="val-events_of_var"><a href="#val-events_of_var" class="anchor"></a><code><span class="keyword">val</span> events_of_var : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="I/index.html#type-var_id">I.var_id</a> <span>&#45;&gt;</span> <span><a href="../../../Domains/Abstract_domain/index.html#type-event">Domains.Abstract_domain.event</a> list</span></code></dt><dd><p><code>events_of_var t v</code> creates the events relevant to the variable `v`. Product domains should not subsume the events of their sub-domains (by replacing the UID). For instance, the domain `Box X Oct` where a variable is both in Box and Oct returns two events for a same variable.</p></dd></dl></div></body></html>