<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>I (absolute.Octagon.OctagonF.I)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">absolute</a> &#x00BB; <a href="../../index.html">Octagon</a> &#x00BB; <a href="../index.html">OctagonF</a> &#x00BB; I</nav><h1>Module <code>OctagonF.I</code></h1><p>The representation of the variables and constraints inside the abstract element. It allows users to turn a logic specification into an abstract element.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dt class="spec type" id="type-var_id"><a href="#type-var_id" class="anchor"></a><code><span class="keyword">type</span> var_id</code></dt><dd><p>Variable ID as represented in the abstract domain.</p></dd></dl><dl><dt class="spec type" id="type-rconstraint"><a href="#type-rconstraint" class="anchor"></a><code><span class="keyword">type</span> rconstraint</code></dt><dd><p>Constraint representation in the abstract domain.</p></dd></dl><dl><dt class="spec value" id="val-exact_interpretation"><a href="#val-exact_interpretation" class="anchor"></a><code><span class="keyword">val</span> exact_interpretation : bool</code></dt><dd><p>`true` if `interpret` always exactly interpret constraint (or fail), false if under- or over-approximations are possible.</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <a href="../../../Typing/Ad_type/index.html#type-ad_uid">Typing.Ad_type.ad_uid</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>An empty interpretation.</p></dd></dl><dl><dt class="spec value" id="val-to_logic_var"><a href="#val-to_logic_var" class="anchor"></a><code><span class="keyword">val</span> to_logic_var : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-var_id">var_id</a> <span>&#45;&gt;</span> <a href="../../../Typing/Tast/index.html#type-tvariable">Typing.Tast.tvariable</a></code></dt><dd><p>Conversion between abstract variables and their logical representations.</p></dd></dl><dl><dt class="spec value" id="val-to_abstract_var"><a href="#val-to_abstract_var" class="anchor"></a><code><span class="keyword">val</span> to_abstract_var : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../Lang/Ast/index.html#type-vname">Lang.Ast.vname</a> <span>&#45;&gt;</span> <a href="index.html#type-var_id">var_id</a> * <a href="../../../Typing/Tast/index.html#type-tvariable">Typing.Tast.tvariable</a></code></dt><dd><p>Conversion between a logical variables and its abstract representation. Raises `Not_found` if the variable is not in `repr`.</p></dd></dl><dl><dt class="spec value" id="val-local_vars"><a href="#val-local_vars" class="anchor"></a><code><span class="keyword">val</span> local_vars : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../Lang/Ast/index.html#type-vname">Lang.Ast.vname</a> <span>&#45;&gt;</span> <span><a href="index.html#type-var_id">var_id</a> list</span></code></dt><dd><p><code>local_vars repr v</code> gives the set of local variables representing `v` in the abstract element `repr`. Same behavior than `to_abstract_var` if the variable has none or a single local variable. In case of multiple variables, these variables must be duplicate, in the sense that they represent the same initial variable (possibly with different level of approximation). For instance, a variable `v` typed in a direct product &quot;A1 X A2&quot; has two versions: one in A1, one in A2.</p></dd></dl><dl><dt class="spec value" id="val-interpret"><a href="#val-interpret" class="anchor"></a><code><span class="keyword">val</span> interpret : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../Domains/Interpretation/index.html#type-approx_kind">Domains.Interpretation.approx_kind</a> <span>&#45;&gt;</span> <a href="../../../Typing/Tast/index.html#type-tformula">Typing.Tast.tformula</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <span><a href="index.html#type-rconstraint">rconstraint</a> list</span></code></dt><dd><p>Interpret a logic formula into a list of abstract constraints. It approximates the representation of the formula if needed according to `approx`. The list of constraints might be empty if the formula is detected to be a tautology. Raise `Wrong_modelling` if: 1. the formula cannot be approximated according to `approx` in the abstract domain. 2. a variable of the formula does not belong to the interpretation.</p></dd></dl><dl><dt class="spec value" id="val-to_qformula"><a href="#val-to_qformula" class="anchor"></a><code><span class="keyword">val</span> to_qformula : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-rconstraint">rconstraint</a> list</span> <span>&#45;&gt;</span> <a href="../../../Typing/Tast/index.html#type-tqformula">Typing.Tast.tqformula</a></code></dt><dd><p>Give a logical representation of an abstract element. This function is the reverse of `interpret`. Note that we do not need to approximate the result as a formula should always be able to represent exactly an element. The free variables in the formula obtained should be considered existentially quantified.</p></dd></dl></div></body></html>